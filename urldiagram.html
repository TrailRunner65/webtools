<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-093YBG598G"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-093YBG598G');
  </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Site Link Flow Diagram</title>
  <meta name="description" content="Internal RunCalcs diagrammer for visualizing site link structure, crawl depth, and navigation flow." />
  <meta name="robots" content="noindex,nofollow" />
  <link rel="canonical" href="https://runcalcs.com/urldiagram.html" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      min-height: 100vh;
      color: #333;
    }

    .container {
      max-width: 100%;
      margin: 0 auto;
    }

    .header {
      background: rgba(255, 255, 255, 0.95);
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    .header-content {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header h1 {
      font-size: 1.8em;
      margin-bottom: 15px;
      color: #1e3c72;
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    input[type="url"] {
      flex: 1;
      min-width: 300px;
      padding: 12px 16px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 15px;
    }

    input[type="url"]:focus {
      outline: none;
      border-color: #2a5298;
    }

    input[type="number"] {
      width: 120px;
      padding: 12px 16px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 15px;
    }

    input[type="number"]:focus {
      outline: none;
      border-color: #2a5298;
    }

    button {
      padding: 12px 28px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s;
      white-space: nowrap;
    }

    button:hover {
      transform: translateY(-2px);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .secondary-btn {
      background: #6c757d;
    }

    .help-text {
      background: #e3f2fd;
      padding: 12px;
      border-radius: 8px;
      font-size: 13px;
      color: #1565c0;
      margin-top: 10px;
    }

    .info-bar {
      background: rgba(255, 255, 255, 0.9);
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }

    .info-bar-content {
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 15px;
    }

    .stats {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }

    .stat {
      display: flex;
      flex-direction: column;
    }

    .stat-label {
      font-size: 0.75em;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-value {
      font-size: 1.5em;
      font-weight: bold;
      color: #1e3c72;
    }

    .legend {
      display: flex;
      gap: 15px;
      align-items: center;
      font-size: 0.85em;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .legend-circle {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .progress-bar {
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      text-align: center;
      display: none;
    }

    .progress-bar.active {
      display: block;
    }

    .progress-text {
      margin-bottom: 10px;
      color: #1e3c72;
      font-weight: 600;
    }

    .progress-track {
      width: 100%;
      max-width: 600px;
      height: 8px;
      background: #e0e0e0;
      border-radius: 4px;
      margin: 0 auto;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      width: 0%;
      transition: width 0.3s;
    }

    #diagram {
      width: 100%;
      height: calc(100vh - 260px);
      background: white;
      cursor: grab;
    }

    #diagram:active {
      cursor: grabbing;
    }

    .node {
      cursor: pointer;
      transition: all 0.3s;
    }

    .node:hover {
      filter: brightness(1.2);
    }

    .node circle {
      stroke: white;
      stroke-width: 2px;
    }

    .node text {
      font-size: 11px;
      pointer-events: none;
      user-select: none;
    }

    .link {
      fill: none;
      stroke: #999;
      stroke-opacity: 0.6;
      stroke-width: 1.5px;
      marker-end: url(#arrowhead);
    }

    .link:hover {
      stroke: #667eea;
      stroke-opacity: 1;
      stroke-width: 2.5px;
    }

    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 13px;
      pointer-events: none;
      z-index: 1000;
      max-width: 400px;
      word-break: break-all;
      display: none;
    }
  </style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="header-content">
      <h1>ðŸ”— Site Link Flow Diagram</h1>
      <div class="controls">
        <input type="url" id="urlInput" placeholder="https://example.com">
        <input type="number" id="maxPages" value="50" min="1" max="200" title="Maximum pages to crawl">
        <button id="analyzeBtn" onclick="analyzeSite()">Analyze Site</button>
        <button class="secondary-btn" onclick="resetDiagram()">Reset</button>
      </div>
      <div class="help-text">
        ðŸ’¡ <strong>How to use:</strong> Enter any website URL and click Analyze. The tool will crawl the site and create an interactive flow diagram showing how pages link to each other.
      </div>
    </div>
  </div>

  <div class="progress-bar" id="progressBar">
    <div class="progress-text" id="progressText">Analyzing site...</div>
    <div class="progress-track">
      <div class="progress-fill" id="progressFill"></div>
    </div>
  </div>

  <div class="info-bar">
    <div class="info-bar-content">
      <div class="stats">
        <div class="stat">
          <span class="stat-label">Pages Crawled</span>
          <span class="stat-value" id="pageCount">0</span>
        </div>
        <div class="stat">
          <span class="stat-label">Total Links</span>
          <span class="stat-value" id="linkCount">0</span>
        </div>
      </div>
      <div class="legend">
        <div class="legend-item">
          <div class="legend-circle" style="background: #667eea;"></div>
          <span>Start Page</span>
        </div>
        <div class="legend-item">
          <div class="legend-circle" style="background: #84fab0;"></div>
          <span>Connected Pages</span>
        </div>
        <div class="legend-item">
          <div class="legend-circle" style="background: #ffd93d;"></div>
          <span>External Links</span>
        </div>
      </div>
    </div>
  </div>

  <svg id="diagram">
    <defs>
      <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="25" refY="3" orient="auto">
        <polygon points="0 0, 10 3, 0 6" fill="#999" />
      </marker>
    </defs>
  </svg>

  <div class="tooltip" id="tooltip"></div>
</div>

<script>
  let simulation;
  let nodes = [];
  let links = [];
  let crawledPages = {};
  let pagesToCrawl = [];
  let maxPagesToAnalyze = 50;

  async function analyzeSite() {
    const url = document.getElementById('urlInput').value.trim();
    maxPagesToAnalyze = parseInt(document.getElementById('maxPages').value) || 50;

    if (!url) {
      alert('Please enter a URL');
      return;
    }

    try {
      new URL(url);
    } catch {
      alert('Please enter a valid URL');
      return;
    }

    // Reset state
    crawledPages = {};
    pagesToCrawl = [url];
    nodes = [];
    links = [];

    document.getElementById('analyzeBtn').disabled = true;
    document.getElementById('progressBar').classList.add('active');
    updateProgress(0, 'Starting crawl...');

    await crawlSite(url);

    document.getElementById('progressBar').classList.remove('active');
    document.getElementById('analyzeBtn').disabled = false;

    if (Object.keys(crawledPages).length === 0) {
      alert('Could not access the website. The site may block automated access or require authentication.');
      return;
    }

    createVisualization();
  }

  async function crawlSite(startUrl) {
    const baseUrl = new URL(startUrl);
    const visited = new Set();
    const queue = [startUrl];

    while (queue.length > 0 && visited.size < maxPagesToAnalyze) {
      const currentUrl = queue.shift();

      if (visited.has(currentUrl)) continue;
      visited.add(currentUrl);

      updateProgress(
              (visited.size / maxPagesToAnalyze) * 100,
              `Crawling page ${visited.size} of ${maxPagesToAnalyze}...`
      );

      const pageLinks = await fetchPageLinks(currentUrl, baseUrl);

      if (pageLinks) {
        crawledPages[currentUrl] = pageLinks;

        // Add new internal links to queue
        pageLinks.forEach(link => {
          if (!visited.has(link) && !queue.includes(link)) {
            queue.push(link);
          }
        });
      }

      // Small delay to be respectful
      await new Promise(resolve => setTimeout(resolve, 200));
    }

    buildGraph();
  }

  async function fetchPageLinks(url, baseUrl) {
    try {
      const response = await fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`);
      if (!response.ok) return null;

      const html = await response.text();
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const anchors = doc.querySelectorAll('a[href]');

      const internalLinks = new Set();

      anchors.forEach(link => {
        let href = link.getAttribute('href');

        if (!href || href.startsWith('#') || href.startsWith('javascript:') ||
                href.startsWith('mailto:') || href.startsWith('tel:')) {
          return;
        }

        try {
          const linkUrl = new URL(href, url);

          if (linkUrl.hostname === baseUrl.hostname) {
            const normalized = normalizeUrl(linkUrl.href);
            internalLinks.add(normalized);
          }
        } catch (e) {
          // Invalid URL
        }
      });

      return Array.from(internalLinks);
    } catch (error) {
      console.error('Error fetching:', url, error);
      return null;
    }
  }

  function buildGraph() {
    const allPages = new Set(Object.keys(crawledPages));
    const startUrl = Object.keys(crawledPages)[0];

    // Add all linked pages
    Object.values(crawledPages).forEach(pageLinks => {
      pageLinks.forEach(link => allPages.add(link));
    });

    // Calculate incoming link counts
    const incomingCounts = {};
    allPages.forEach(page => incomingCounts[page] = 0);

    Object.entries(crawledPages).forEach(([source, targets]) => {
      targets.forEach(target => {
        if (incomingCounts[target] !== undefined) {
          incomingCounts[target]++;
        }
      });
    });

    // Create nodes
    nodes = Array.from(allPages).map(page => {
      const isCrawled = crawledPages.hasOwnProperty(page);
      const isStart = page === startUrl;

      return {
        id: page,
        label: getPageLabel(page),
        fullUrl: page,
        isStart: isStart,
        isCrawled: isCrawled,
        incomingCount: incomingCounts[page] || 0,
        outgoingCount: (crawledPages[page] || []).length
      };
    });

    // Create links
    links = [];
    Object.entries(crawledPages).forEach(([source, targets]) => {
      targets.forEach(target => {
        if (source !== target && allPages.has(target)) {
          links.push({
            source: source,
            target: target
          });
        }
      });
    });

    // Update stats
    document.getElementById('pageCount').textContent = Object.keys(crawledPages).length;
    document.getElementById('linkCount').textContent = links.length;
  }

  function normalizeUrl(url) {
    const urlObj = new URL(url);
    let normalized = urlObj.origin + urlObj.pathname;
    if (normalized.endsWith('/') && normalized.length > urlObj.origin.length + 1) {
      normalized = normalized.slice(0, -1);
    }
    return normalized;
  }

  function getPageLabel(url) {
    try {
      const urlObj = new URL(url);
      let path = urlObj.pathname;

      if (path === '/' || path === '') {
        return 'Home';
      }

      const segments = path.split('/').filter(s => s);
      let label = segments[segments.length - 1];

      label = label.replace(/\.(html|htm|php|asp|aspx)$/i, '');
      label = label.replace(/[-_]/g, ' ');
      label = label.split(' ')
              .map(word => word.charAt(0).toUpperCase() + word.slice(1))
              .join(' ');

      if (label.length > 20) {
        label = label.substring(0, 20) + '...';
      }

      return label || 'Page';
    } catch {
      return 'Page';
    }
  }

  function updateProgress(percent, text) {
    document.getElementById('progressFill').style.width = percent + '%';
    document.getElementById('progressText').textContent = text;
  }

  function createVisualization() {
    const svg = d3.select('#diagram');
    const width = svg.node().getBoundingClientRect().width;
    const height = svg.node().getBoundingClientRect().height;

    svg.selectAll('*:not(defs)').remove();

    const g = svg.append('g');

    const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => {
              g.attr('transform', event.transform);
            });

    svg.call(zoom);

    simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links)
                    .id(d => d.id)
                    .distance(150))
            .force('charge', d3.forceManyBody().strength(-400))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(60));

    const link = g.append('g')
            .selectAll('path')
            .data(links)
            .enter()
            .append('path')
            .attr('class', 'link')
            .on('mouseover', function(event, d) {
              showTooltip(event, `${getPageLabel(d.source.id)} â†’ ${getPageLabel(d.target.id)}`);
            })
            .on('mouseout', hideTooltip);

    const node = g.append('g')
            .selectAll('g')
            .data(nodes)
            .enter()
            .append('g')
            .attr('class', 'node')
            .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
            .on('click', (event, d) => {
              window.open(d.fullUrl, '_blank');
            })
            .on('mouseover', function(event, d) {
              const info = `<strong>${d.label}</strong><br>${d.fullUrl}<br><small>In: ${d.incomingCount} | Out: ${d.outgoingCount}</small>`;
              showTooltip(event, info);
            })
            .on('mouseout', hideTooltip);

    node.append('circle')
            .attr('r', d => {
              const totalLinks = d.incomingCount + d.outgoingCount;
              return 15 + Math.min(totalLinks * 2, 30);
            })
            .attr('fill', d => {
              if (d.isStart) return '#667eea';
              if (d.isCrawled) return '#84fab0';
              return '#ffd93d';
            });

    node.append('text')
            .text(d => d.label)
            .attr('text-anchor', 'middle')
            .attr('dy', d => {
              const totalLinks = d.incomingCount + d.outgoingCount;
              const radius = 15 + Math.min(totalLinks * 2, 30);
              return radius + 15;
            })
            .style('fill', '#333')
            .style('font-weight', '600');

    simulation.on('tick', () => {
      link.attr('d', d => {
        const dx = d.target.x - d.source.x;
        const dy = d.target.y - d.source.y;
        const dr = Math.sqrt(dx * dx + dy * dy);
        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
      });

      node.attr('transform', d => `translate(${d.x},${d.y})`);
    });

    svg.call(zoom.transform, d3.zoomIdentity);
  }

  function dragstarted(event, d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
  }

  function dragended(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }

  function showTooltip(event, html) {
    const tooltip = document.getElementById('tooltip');
    tooltip.innerHTML = html;
    tooltip.style.display = 'block';
    tooltip.style.left = (event.pageX + 10) + 'px';
    tooltip.style.top = (event.pageY + 10) + 'px';
  }

  function hideTooltip() {
    document.getElementById('tooltip').style.display = 'none';
  }

  function resetDiagram() {
    document.getElementById('urlInput').value = '';
    d3.select('#diagram').selectAll('*:not(defs)').remove();
    document.getElementById('pageCount').textContent = '0';
    document.getElementById('linkCount').textContent = '0';
    nodes = [];
    links = [];
    crawledPages = {};
  }
</script>
</body>
</html>
